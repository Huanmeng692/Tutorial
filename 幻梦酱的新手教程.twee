:: StoryTitle
幻梦酱的新手教程


:: StoryData
{
  "ifid": "01155382-7ADE-430A-A9E6-57E047E37F27",
  "format": "SugarCube",
  "format-version": "2.37.3",
  "start": "Start",
  "zoom": 1
}


:: StoryAuthor
幻梦酱


:: StoryBanner
[幻梦酱的故事横幅]

:: StoryCaption
[[打开目录|Catalog]]


:: StoryMenu
[[这里也可以打开目录|Catalog]]


:: Catalog
- [[开始|Start]]
----
- [[第一章：片段|Chapter1]]
- [[第二章：链接|Chapter2]]
- [[第三章：多媒体内容|Chapter3]]
- [[第四章：变量|Chapter4]]
- [[第五章：链接宏和更新宏|Chapter5]]
- [[第六章：条件宏|Chapter6]]
- [[第七章：循环宏|Chapter7]]
- [[第八章：捕获宏|Chapter8]]
----
- [[第九章：特殊段落和标签|Chapter9]]
- [[第十章：数组和对象|Chapter10]]


:: StoryInit
<<set $SpecialNameText to [
  "这个片段的内容会在每个故事片段完成显示后执行一次，适用于需要在每个片段显示后执行的代码，比如重新设置变量、重新设置片段内容的样式等，由于此时片段内变量内容已完成渲染，直接修改相关变量并不会更新片段内相应内容的显示。",
  "这个片段的内容会附加到每个故事片段的顶部，适用于需要在每个片段顶部显示的内容，比如导航链接、章节标题等。",
  "这个片段的内容会在每个故事片段开始渲染前执行一次，适用于需要在每个片段开始渲染前执行的代码，比如初始化变量、设置片段内容的样式等，由于此时片段内容还没有开始渲染，因此修改相关变量会更新片段内相应内容的显示。",
  "这个片段用于填充界面栏中的作者署名区域，在故事标题下方，元素的ID为story-author",
  "这个片段用于填充界面栏中的故事横幅区域，在故事标题上方，元素的ID为story-banner",
  "这个片段用于填充界面栏中的故事标题区域，它就是故事标题，元素的ID为story-caption",
  "这个片段用于设置浏览器的标题栏和UI栏中的显示标题，元素的ID为story-title，如果省略，会默认使用故事标题作为显示标题。",
  "这个片段的内容会在故事开始前执行一次，之后不会再次运行，适用于需要在故事开始前执行的代码，比如初始化变量。",
  "这个片段用于填充界面栏中的菜单区域，元素的ID为story-menu，这个部分虽然会显示内容，但仅显示按钮和链接等内容，不能显示文本内容。",
  "这个片段用于填充界面栏中的故事副标题区域，在故事标题下方，元素的ID为story-subtitle",
  "这个标签用于将段落注册为小组件片段，它会在游戏启动时进行加载（时机早于StoryInit片段），注册为小组件片段后，与其他特殊片段一样，不能在故事中通过链接进行访问，但可以在其他片段中使用{{{<<widget>>}}}宏来调用。",
  "这个标签会在段落渲染之前删除前导/尾随换行符，并将所有剩余的换行符序列替换为单个空格，相当于将整个段轮廓包裹在{{{<<nobr>>}}}宏内。"
]>>
<<set $SpecialName to {
  PassageDone:{
    class:"故事片段渲染后",
    text:0,
    output:"false"
  },
  PassageHeader:{
    class:"故事片段渲染时",
    text:1,
    output:"true"
  },
  PassageReady:{
    class:"故事片段渲染前",
    text:2,
    output:"false"
  },
  StoryAuthor:{
    class:"故事开始时",
    text:3,
    output:"true"
  },
  StoryBanner:{
    class:"故事开始时",
    text:4,
    output:"true"
  },
  StoryCaption:{
    class:"故事开始时",
    text:5,
    output:"true"
  },
  StoryDisplayTitle:{
    class:"故事开始时",
    text:6,
    output:"true"
  },
  StoryInit:{
    class:"故事开始前",
    text:7,
    output:"false"
  },
  StoryMenu:{
    class:"故事开始时",
    text:8,
    output:"true"
  },
  StorySubtitle:{
    class:"故事开始时",
    text:9,
    output:"true"
  },
  widget:{
    class:"故事片段渲染时",
    text:10,
    output:"true"
  },
  nobr:{
    class:"故事片段渲染时",
    text:11,
    output:"true"
  }
}>>


:: Start {"position":"400,300","size":"100,100"}
恭喜你，当你看到这一行文字，意味着你的电脑浏览器可以正常使用，拥有了调试的环境，正所谓好的开始是成功的一半，这说明了你已经取得了一半的胜利。

但是，不要骄傲，接下来还有很多东西需要你去学习。

首先，你需要确定你已经安装了最新版本的Twine软件，并且已经安装了SugarCube格式的故事格式。

如果你还没有安装Twine软件，可以访问<a href="https://twinery.org/" target="_blank">Twine官网</a>下载最新版本。
如果你不确定使用的是否为SugarCube格式，可以在Twine软件中点击“Twine-故事格式”按钮，然后选择“SugarCube 2.37.3”，并点击“设为默认故事格式”。

在确认上述步骤已经完成后，你可以点击下面的链接，进入基础部分内容的学习。
若你已经熟悉了基础部分的内容，可以直接跳转到进阶部分的学习。

[[开始基础章节|Chapter1]]

[[进入进阶章节|Chapter9]]


:: Chapter1
Twine的基础是片段和链接，片段是Twine故事的基本构建块，而链接则是连接不同片段的桥梁。
在Twine中，片段是一个独立的文本块，它可以包含任何内容，包括文本、图片、音频等。

每个片段都有一个唯一的标题，用于标识和引用该片段。
片段的标题可以是任何文本，但通常建议使用简短且具有描述性的标题，以便于在故事中进行引用和链接。

片段的内容可以是纯文本，也可以包含HTML、CSS和JavaScript等代码。
现在你看到的内容就是一个片段的内容，它的标题是“Chapter1”，你可以在Twine中创建更多的片段来丰富你的故事。

[[下一章|Chapter2]]


:: Chapter2
恭喜你，刚刚成功的点击了Twine的链接，在Twine中，链接是非常重要的一个概念，它可以让你在不同的片段之间进行跳转。
在Twine中，链接的语法非常简单，只需要使用双括号包裹住链接的文本即可。

例如，[[新页面]]表示点击“新页面”这个链接后，会跳转到名为“新页面”的章节。它的写法是：{{{[[新页面]]}}}
在Twine中，直接使用双括号包裹住片段标题是最简单的创建连接的方式，但这样做也有一个缺点，那就是显示的链接文本是片段标题本身，这可能不是你想要的效果。

为了更好地控制链接的显示文本，你可以使用以下语法：{{{[[链接文本|片段标题]]}}}
这样，你可以将“链接文本”替换为你想要显示的文本，而“片段标题”则是你想要跳转到的章节标题。
例如[[跳转到新页面|新页面]]，表示点击“跳转到新页面”这个链接后，会跳转到名为“新页面”的章节。

链接的片段可以是你故事中任意片段，包括所在的这个片段本身，如果链接跳转的片段不存在，Twine会自动创建一个新的片段。

在Twine中，链接是一个十分重要的功能，任何一个片段如果没有链接指向它，它就无法被访问到。

[[下一章|Chapter3]]


:: 新页面
这里是一个新页面
[[返回上一页|Chapter2]]

:: Chapter3
除了文字外，Twine还支持在片段中插入图片、音频等多媒体内容。
例如：[img[这是一枚可爱的芙芙|img/可爱的芙芙.jpg]]

你可以使用HTML标签来插入这些内容，例如使用{{{<img>}}}标签来插入图片，使用{{{<audio>}}}标签来插入音频。
你也可以使用Twine的内置宏来实现相同的功能，例如{{{<<audio>>}}}来插入音频文件。
Twine没有图像宏，但有更加简便的插入图像方式：{{{[img[image.jpg]]}}}，其中image.jpg是你想要插入的图片文件名。
如果你希望插入的图片在点击时可以跳转到其他片段，可以使用{{{[img[image.jpg|链接文本]]}}}的方式。
例如，{{{[img[image.jpg][新页面]]}}}

[[下一章|Chapter4]]


:: Chapter4
在Twine中，你可以使用变量来存储和管理数据。
变量可以用来存储用户的选择、游戏状态等信息，以便在不同的片段之间进行传递和使用。

你可以使用{{{<<set>>}}}宏来创建和设置变量，例如{{{<<set $variableName to "value">>}}}。
变量名通常以$符号或_符号开头，以便于区分它们与普通文本。
在上面的例子中{{{$variableName}}}是变量的名称，"value"是你想要存储的值。

$开头的变量是全局变量，可以在任何片段中访问和修改。
_开头的变量是局部变量，只能在当前片段中访问和修改。

Twine中变量支持的类型与JavaScript类似，包括字符串、数字、布尔值等，也可以存储数组和对象等复杂数据结构。
你可以直接使用裸变量来引用变量的值，例如{{{$variableName}}}，Twine会自动将其替换为变量的实际值。
也可以使用{{{<<print $variableName>>}}}或{{{<<=>>}}}宏来输出变量的值。

除了使用{{{<<set>>}}}宏来设置和修改变量外，你还可以在Twine的链接中对变量进行操作。
例如，{{{[[跳转页面|新页面][$variableName to "value"]]}}}表示在跳转到“新页面”时，将变量{{{$variableName}}}的值设置为"value"。
同理，图片链接也可以使用类似的方式，例如{{{[img[image.jpg][新页面][$variableName to "value"]]}}}。

变量也可以作为片段标题的一部分来使用，例如{{{[[$variableName]]}}}，这表示点击链接后会跳转到名为“$variableName”的变量的值的片段。
你可以尝试点击下面的链接来测试变量的使用。
将{{{$variableName}}}变量设置为：（<<nobr>><<set $variableName to "新页面A">>
<<link "新页面A">><<set $variableName to "新页面A">><<redo>><</link>> /
<<link "新页面B">><<set $variableName to "新页面B">><<redo>><</link>> /
<<link "下一章">><<set $variableName to "Chapter5">><<redo>><</link>> 
<</nobr>>)
观察下面的跳转链接的变化，你可以点击它看看会进入什么页面：
<<do>>[[$variableName]]<</do>>


:: 新页面A
这个片段的标题是新页面A

[[返回上一页|Chapter4]]


:: 新页面B
这个片段的标题是新页面B

[[返回上一页|Chapter4]]


:: 新页面C
这个片段的标题是新页面C

[[返回上一页|Chapter5]]


:: 新页面D
这个片段的标题是新页面D

[[返回上一页|Chapter5]]


:: Chapter5
你是否发现，上一章出现了点击后不会跳转到新片段的情况？
这是因为使用了不同于{{{[[新页面]]}}}的另一种链接方式：{{{<<link "链接文本">>链接内容<</link>}}}。
在{{{<<link>>}}}宏中，除了可以设置和{{{[[新页面]]}}}一样的跳转链接外，还可以在链接中添加其他内容，例如设置变量、执行代码等。
例如{{{<<link "新页面A">><<set $variableName to "新页面A">><<redo>><</link>>}}}，它的作用不是跳转到新页面A，而是设置变量{{{$variableName}}}的值为“新页面A”。
现在你可以尝试点击下面的链接，看看会发生什么：
将{{{$variableName}}}变量设置为：（<<nobr>><<set $variableName to "新页面C">>
<<link "新页面C">><<set $variableName to "新页面C">><<redo>><</link>> /
<<link "新页面D">><<set $variableName to "新页面D">><<redo>><</link>>
<</nobr>>)
现在{{{$variableName}}}的值为：<<do>>$variableName<</do>>
再次观察下面的跳转链接的变化：
[[$variableName]]
是不是发现无论将{{{$variableName}}}设置成什么，上面的链接都没有发生变化？
问题出在了哪里？
这是上一章的链接部分：
{{{
将$variableName变量设置为：（<<nobr>><<set $variableName to "新页面A">>
<<link "新页面A">><<set $variableName to "新页面A">><<redo>><</link>> /
<<link "新页面B">><<set $variableName to "新页面B">><<redo>><</link>> /
<<link "下一章">><<set $variableName to "Chapter5">><<redo>><</link>> 
<</nobr>>)
观察下面的跳转链接的变化，你可以点击它看看会进入什么页面：
<<do>>[[$variableName]]<</do>>
}}}
这是这一章的链接部分：
{{{
将$variableName变量设置为：（<<nobr>><<set $variableName to "新页面C">>
<<link "新页面C">><<set $variableName to "新页面C">><<redo>><</link>> /
<<link "新页面D">><<set $variableName to "新页面D">><<redo>><</link>>
<</nobr>>)
现在$variableName的值为：<<do>>$variableName<</do>>
再次观察下面的跳转链接的变化：
[[$variableName]]
}}}
是不是发现，相比于上一章，这一章的跳转链接部分没有使用{{{<<do>>}}}宏？
这就是问题所在。
在Twine中，{{{<<do>>}}}宏用于在{{{<<redo>>}}}宏被触发的时候，执行内部包裹的代码并刷新结果。
如果没有使用{{{<<do>>}}}宏和{{{<<redo>>}}}宏，Twine就不会重新渲染片段内容，因此即使修改了变量的值，当前片段内使用变量的部分也不会更新，这在使用{{{<<link>>}}}宏时尤其明显。
所以，如果你想要在当前片段中修改已显示的变量的值并实时更新，必须使用{{{<<do>>}}}宏来包裹住变量的值，并在触发的链接中加入{{{<<redo>>}}}。

[[下一章|Chapter6]]


:: Chapter6
变量除了用在链接中之外，还可以用在其他地方，比如根据变量的值进行判断，显示不同的内容。
这就要用到条件宏了。
在Twine中，条件宏分为两种，第一种为{{{<<if>>}}}宏，第二种为{{{<<switch>>}}}宏。
{{{<<if>>}}}宏用于根据条件判断来执行不同的代码块，而{{{<<switch>>}}}宏则用于根据变量的值来选择执行不同的代码块。
{{{<<if>>}}}宏的语法如下：
{{{
<<if (条件语句)>>
(条件为真时执行的代码)
<<elseif (条件语句)>>(可选，可重复多次)
(条件为真时执行的代码)
<<else>>(可选)
(条件为假时执行的代码)
<</if>>
}}}
{{{<<switch>>}}}宏的语法如下：
{{{
<<switch (变量名或表达式)>>
<<case (值)>> (可选，可重复多次)
(值匹配时执行的代码)
<<default>>(可选)
(没有匹配到任何值时执行的代码)
<</switch>>
}}}
{{{<<if>>}}}宏和{{{<<switch>>}}}宏都可以嵌套使用，也可以和其他宏结合使用。
其中{{{<<if>>}}}宏的条件语句的值必须为布尔值（true或false），而{{{<<switch>>}}}宏的变量名或表达式可以是任何类型的值。
常用的条件语句包括比较运算符（如{{{==}}}、{{{===}}}、{{{!=}}}、{{{!==}}}、{{{<}}}、{{{<=}}}、{{{>}}}、{{{>=}}}）和逻辑运算符（如{{{&&}}}、{{{||}}}）。
特别注意，{{{==}}}和{{{===}}}的区别在于，前者会先对运算符右边的值进行类型转换后比较，而后者不会。
而{{{!=}}}和{{{!==}}}的区别在于，前者会先对运算符右边的值进行类型转换后比较，而后者不会。
{{{=}}}是赋值运算符，而不是比较运算符，所以在条件语句中不能使用{{{=}}}。
同样，在同一个片段内的变量发生变化时，想要同步更新条件判断的结果，也需要使用{{{<<do>>}}}宏来包裹住条件判断的代码块，并在触发的链接中加入{{{<<redo>>}}}。

[[下一章|Chapter7]]


:: Chapter7
除了{{{<<if>>}}}和{{{<<switch>>}}}之外，Twine还提供了另一种条件宏，也就是{{{<<for>>}}}宏。
{{{<<for>>}}}宏的用途是重复多次执行其包含的内容，直到满足某个条件为止。
{{{<<for>>}}}宏有三种形式：
{{{
<<for [conditional]>> … <</for>>（写法最简便，适用于循环内容自带条件判断的情况）
<<for [init] ; [conditional] ; [post]>> … <</for>>（适用性最广泛，可直接设定循环次数，也可以根据当前情况灵活判断循环次数）
<<for [[keyVariable ,] valueVariable] range collection>> … <</for>>（适用于数组元素遍历）
}}}
其中conditional为条件语句，每次循环开始前都会判断，如果为真则执行循环，init为初始化语句，第一次执行循环前对循环变量进行初始化，post为后置语句，每次循环后执行一遍，keyVariable为键变量，初始会被设定为0，每次循环后加一，valueVariable为值变量，是当前循环时数组的元素，range为范围关键字，collection为要执行循环的数组变量，循环过程中不会进行修改。除了range和collection外，其他参数都是可选的。
{{{<<for>>}}}宏用于循环执行代码块，直到条件不满足为止。
{{{<<for>>}}}宏的第一种形式和第二种形式类似于JavaScript中的for循环，而第三种形式则类似于Python中的for循环。
{{{<<for>>}}}宏可以嵌套使用，也可以和其他宏结合使用。
下面是一个使用{{{<<for>>}}}宏遍历数组{{{$collection}}}按顺序输出数组每个元素的示例，分别使用三种形式：
{{{
// 第一种形式
<<set _i to 0>>
<<for _i < $collection.length>>
  $collection[_i]
  <<set _i to _i + 1>>
<</for>>
// 第二种形式
<<for _i = 0 ; _i < $collection.length ; _i++>>
  $collection[_i]
<</for>>
// 第三种形式
<<for _value range $collection>>
  _value
<</for>>
}}}
在{{{<<for>>}}}宏中，可以使用{{{<<break>>}}}宏来提前结束循环，使用{{{<<continue>>}}}宏来跳过当前循环的剩余部分并开始下一次循环。

[[下一章|Chapter8]]


:: Chapter8
上一章所介绍的{{{<<for>>}}}宏是Twine中最常用的循环宏之一，它可以用于显示数组元素、执行重复操作等。
然而，若要在循环完成后使用循环中的变量，可能会遇到一些问题。
其中一个问题是，循环结束后，循环变量的值可能不是你期望的结果。
例如上一章的这个循环语句，如果想要用数组元素的值作为链接跳转的片段名：
{{{
<<for _value range $collection>>
  [[_value]]
<</for>>
}}}
它会输出数组{{{$collection}}}中的每个元素,并创建相应的链接，但循环结束后，由于变量{{{_value}}}的值将是数组的最后一个元素，无论点击其中哪一个链接，跳转的结果都会是最后一个元素的值所代表的片段。

为了解决这个问题，Twine提供了{{{<<capture>>}}}宏。
{{{<<capture>>}}}宏可以捕获循环中的变量值，在宏的内容中创建其值的本地化版本，并在循环结束后使用。
{{{<<capture>>}}}宏可以用于捕获任何变量的值，包括全局变量和局部变量。
它的语法如下：
{{{
<<capture variableName>>内容<</capture>>
}}}
其中，{{{variableName}}}是你想要捕获的变量名，内容是你想要捕获的内容。
因此，上面的循环可以改为：
{{{
<<for _value range $collection>>
  <<capture _value>>[[_value]]<</capture>>
<</for>>
}}}
这样，每次循环时，{{{_value}}}的值都会被捕获并创建相应的本地化版本，点击链接时就会跳转到对应的片段，而不是最后一个元素的值所代表的片段。


[[进入进阶章节|Chapter9]]


:: Chapter9 [nobr]
在Twine中，除了基本的片段和链接外，还有一些特殊的片段和标签。
其中特殊片段是Twine内置有着特殊作用的片段，它们有着各自的功能，不应该在故事中通过链接进行访问。
以下是Twine内置的特殊片段和标签，你可以点击这些链接查看其具体功能：<<set _name to $SpecialName.PassageReady>>
<div id="chapter9-body">
<div id="chapter9-left">
<br>Passage片段<br><br>
<<link "PassageReady">><<set _name to $SpecialName.PassageReady>><<redo>><</link>><br>
<<link "PassageHeader">><<set _name to $SpecialName.PassageHeader>><<redo>><</link>><br>
<<link "PassageDone">><<set _name to $SpecialName.PassageDone>><<redo>><</link>><br>
<br>Story片段<br><br>
<<link "StoryInit">><<set _name to $SpecialName.StoryInit>><<redo>><</link>><br>
<<link "StoryMenu">><<set _name to $SpecialName.StoryMenu>><<redo>><</link>><br>
<<link "StoryCaption">><<set _name to $SpecialName.StoryCaption>><<redo>><</link>><br>
<<link "StoryAuthor">><<set _name to $SpecialName.StoryAuthor>><<redo>><</link>><br>
<<link "StoryBanner">><<set _name to $SpecialName.StoryBanner>><<redo>><</link>><br>
<<link "StoryDisplayTitle">><<set _name to $SpecialName.StoryDisplayTitle>><<redo>><</link>><br>
<<link "StorySubtitle">><<set _name to $SpecialName.StorySubtitle>><<redo>><</link>><br>
<br>特殊标签<br><br>
<<link "widget">><<set _name to $SpecialName.widget>><<redo>><</link>><br>
<<link "nobr">><<set _name to $SpecialName.nobr>><<redo>><</link>><br>
</div>
<div id="chapter9-right"><<do>>
<div id="chapter9-right-class">运行或渲染时机：_name.class</div>
<div id="chapter9-right-output">是否会显示内容：<<= _name.output ? "是" : "否" >></div>
<div id="chapter9-right-text"><<= $SpecialNameText[_name.text]>></div>
<</do>></div>
</div>

[[下一章|Chapter10]]


:: Chapter10
在Twine中，数组和对象是两种常用的数据结构。

数组是一种有序的数据集合，可以存储多个值，每个值都有一个索引。
它的结构为：{{{[value1, value2, value3]}}}，其中{{{value1}}}、{{{value2}}}和{{{value3}}}是数组中的元素，它们的索引从0开始依次递增。
若要访问数组中的元素，可以使用{{{$array[index]}}}的方式，其中{{{$array}}}是数组的名称，{{{index}}}是元素的索引。

对象是一种无序的数据集合，可以存储多个键值对，每个键都有一个唯一的名称。
它的结构为：{{{{"key1": "value1", "key2": "value2"}}}}，其中{{{key1}}}和{{{key2}}}是对象中的键，{{{"value1"}}}和{{{"value2"}}}是对应的值。
若要访问对象中的值，可以使用{{{$object.key}}}的方式，其中{{{$object}}}是对象的名称，{{{key}}}是键的名称。

你可以使用{{{<<set>>}}}宏来创建和设置数组和对象。
例如，{{{<<set $array to [1, 2, 3]>>}}}表示创建一个名为{{{$array}}}的数组，包含三个元素1、2和3。
同样，{{{<<set $object to {key1: "value1", key2: "value2"}>>}}}表示创建一个名为{{{$object}}}的对象，包含两个键值对，键为{{{key1}}}和{{{key2}}}，对应的值为{{{"value1"}}}和{{{"value2"}}}。

数组的元素可以是任何类型的值，包括字符串、数字、布尔值、对象等。
对象的值也可以是任何类型的值，包括数组、字符串、数字、布尔值等。
你可以根据实际情况灵活运用，将数组和对象结合使用来存储和管理数据。
例如这样的变量：
{{{
  <<set $testvar to {
    name: "测试变量",
    value: 123,
    tags: ["tag1", "tag2"],
    nestedObject: {
      key1: "value1",
      key2: "value2"
    }
  }>>
}}}
当你需要访问它的name属性时，可以使用{{{$testvar.name}}}，访问value属性时可以使用{{{$testvar.value}}}，访问tags数组的第一个元素时可以使用{{{$testvar.tags[0]}}}，访问nestedObject对象的key1属性时可以使用{{{$testvar.nestedObject.key1}}}。

:: StoryScript [script]


:: StoryStylesheet [stylesheet]
#chapter9-body {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: flex-start;
}
#chapter9-left {
  width: 20%;
  padding: 10px;
}
#chapter9-right {
  width: 80%;
  padding: 10px;
}

div#passage-chapter3 img {
  width: 100px;
}
